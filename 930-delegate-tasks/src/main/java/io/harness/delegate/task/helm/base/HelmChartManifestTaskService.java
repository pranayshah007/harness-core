/*
 * Copyright 2023 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

package io.harness.delegate.task.helm;
import static io.harness.data.structure.EmptyPredicate.isEmpty;
import static io.harness.data.structure.EmptyPredicate.isNotEmpty;
import static io.harness.delegate.beans.storeconfig.StoreDelegateConfigType.GIT;
import static io.harness.helm.HelmConstants.CHARTS_YAML_KEY;

import static java.lang.String.format;

import io.harness.annotations.dev.CodePulse;
import io.harness.annotations.dev.HarnessModuleComponent;
import io.harness.annotations.dev.HarnessTeam;
import io.harness.annotations.dev.OwnedBy;
import io.harness.annotations.dev.ProductModule;
import io.harness.aws.AwsClient;
import io.harness.aws.beans.AwsInternalConfig;
import io.harness.connector.task.git.ScmConnectorMapperDelegate;
import io.harness.delegate.beans.connector.awsconnector.AwsConnectorDTO;
import io.harness.delegate.beans.connector.helm.OciHelmConnectorDTO;
import io.harness.delegate.beans.connector.scm.genericgitconnector.GitConfigDTO;
import io.harness.delegate.beans.storeconfig.FetchType;
import io.harness.delegate.beans.storeconfig.GcsHelmStoreDelegateConfig;
import io.harness.delegate.beans.storeconfig.GitStoreDelegateConfig;
import io.harness.delegate.beans.storeconfig.HttpHelmStoreDelegateConfig;
import io.harness.delegate.beans.storeconfig.OciHelmStoreDelegateConfig;
import io.harness.delegate.beans.storeconfig.S3HelmStoreDelegateConfig;
import io.harness.delegate.task.aws.AwsNgConfigMapper;
import io.harness.delegate.task.git.GitFetchTaskHelper;
import io.harness.delegate.task.helm.beans.FetchHelmChartManifestRequest;
import io.harness.delegate.task.helm.response.HelmChartManifest;
import io.harness.delegate.task.k8s.HelmChartManifestDelegateConfig;
import io.harness.exception.InvalidArgumentsException;
import io.harness.exception.InvalidRequestException;
import io.harness.exception.NestedExceptionUtils;
import io.harness.filesystem.FileIo;
import io.harness.git.model.FetchFilesResult;
import io.harness.helm.HelmChartYaml;
import io.harness.helm.HelmChartYamlMapper;
import io.harness.logging.NoopExecutionCallback;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.experimental.FieldNameConstants;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.tuple.Pair;

@CodePulse(module = ProductModule.CDS, unitCoverageRequired = true, components = {HarnessModuleComponent.CDS_K8S})
@Slf4j
@Singleton
@OwnedBy(HarnessTeam.CDP)
public class HelmChartManifestTaskService {
  private static final long CHART_CACHE_EXPIRE_AFTER_ACCESS_H = 1L;
  private static final long CHART_CACHE_EXPIRE_AFTER_WRITE_H = 2L;

  @Inject private HelmTaskHelperBase helmTaskHelperBase;

  @Inject private GitFetchTaskHelper gitFetchTaskHelper;
  @Inject private ScmConnectorMapperDelegate scmConnectorMapperDelegate;
  @Inject private static AwsClient awsClient;
  @Inject private static AwsNgConfigMapper awsNgConfigMapper;

  private final Cache<HelmChartKey, HelmChartManifest> cache =
      CacheBuilder.newBuilder()
          .expireAfterAccess(Duration.ofHours(CHART_CACHE_EXPIRE_AFTER_ACCESS_H))
          .expireAfterWrite(Duration.ofHours(CHART_CACHE_EXPIRE_AFTER_WRITE_H))
          .build();

  public HelmChartManifest fetchHelmChartManifest(FetchHelmChartManifestRequest request) throws Exception {
    HelmChartMetadata metadata = createMetadata(request.getManifestDelegateConfig());
    Optional<HelmChartKey> helmChartKey = metadata.toHelmChartKey();
    if (helmChartKey.isPresent()) {
      HelmChartManifest helmChartManifest = cache.getIfPresent(helmChartKey.get());
      if (helmChartManifest == null) {
        helmChartManifest = fetchAndReadHelmChartYaml(request, metadata);
        cache.put(helmChartKey.get(), helmChartManifest);
      }

      return helmChartManifest;
    }

    return fetchAndReadHelmChartYaml(request, metadata);
  }

  private HelmChartManifest fetchAndReadHelmChartYaml(
      FetchHelmChartManifestRequest request, HelmChartMetadata metadata) {
    final File helmChartYamlFile;
    final HelmChartManifestDelegateConfig manifestConfig = request.getManifestDelegateConfig();
    try {
      helmChartYamlFile = fetchHelmChartYaml(
          manifestConfig, request.getWorkingDirectory(), request.getAccountId(), request.getTimeoutInMillis());
    } catch (RuntimeException e) {
      throw e;
    } catch (Exception e) {
      log.error("Failed to fetch helm chart", e);
      throw new InvalidRequestException("Failed to fetch helm chart: " + e.getMessage());
    }

    try (InputStream stream = new FileInputStream(helmChartYamlFile)) {
      HelmChartYaml helmChartYaml = HelmChartYamlMapper.deserialize(stream);
      return HelmChartManifest.create(helmChartYaml, metadata.toMap());
    } catch (FileNotFoundException | NoSuchFileException e) {
      log.warn("Unable to find Chart.yaml in file path: {}", helmChartYamlFile.getPath());
      String helmVersion = isNotEmpty(manifestConfig.getChartVersion())
          ? format("%s:%s", manifestConfig.getChartName(), manifestConfig.getChartVersion())
          : manifestConfig.getChartName();
      throw NestedExceptionUtils.hintWithExplanationException(
          format("Check if provided %s helm package is a valid helm chart", helmVersion),
          "Unable to find Chart.yaml in helm chart package. Chart.yaml file is required for helm charts",
          new InvalidArgumentsException(Pair.of(helmVersion, "Missing Chart.yaml file in helm chart package")));
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  private File fetchHelmChartYaml(HelmChartManifestDelegateConfig manifestConfig, String destinationDirectory,
      String accountId, long timeout) throws Exception {
    // TODO (abosii-harness) Ideally all the fetch logic should be handled in one place. Currently there is
    //  a different logic for K8s & Native Helm, and the behavior may be different between swimlanes
    if (GIT == manifestConfig.getStoreDelegateConfig().getType()) {
      fetchHelmChartYamlFromGit(manifestConfig, accountId, destinationDirectory);
    } else {
      helmTaskHelperBase.decryptEncryptedDetails(manifestConfig);
      fetchHelmChartYamlFromHelmRepo(manifestConfig, destinationDirectory, timeout);
    }

    return findHelmChartYaml(manifestConfig, destinationDirectory);
  }

  private void fetchHelmChartYamlFromGit(
      HelmChartManifestDelegateConfig manifestConfig, String accountId, String destinationDirectory) throws Exception {
    GitStoreDelegateConfig gitStoreDelegateConfig = (GitStoreDelegateConfig) manifestConfig.getStoreDelegateConfig();
    gitFetchTaskHelper.decryptGitConfig(gitStoreDelegateConfig);
    if (isEmpty(gitStoreDelegateConfig.getPaths())) {
      return;
    }

    final String chartPath = gitStoreDelegateConfig.getPaths().get(0);
    GitConfigDTO gitConfigDTO = scmConnectorMapperDelegate.toGitConfigDTO(
        gitStoreDelegateConfig.getGitConfigDTO(), gitStoreDelegateConfig.getEncryptedDataDetails());
    String chartYamlPath = getChartYamlPath(manifestConfig, chartPath);

    FetchFilesResult result = gitFetchTaskHelper.fetchFileFromRepo(
        gitStoreDelegateConfig, Collections.singletonList(chartYamlPath), accountId, gitConfigDTO, false);
    if (isEmpty(result.getFiles())) {
      return;
    }

    String chartYamlContent = result.getFiles().get(0).getFileContent();
    if (isEmpty(chartYamlContent)) {
      return;
    }

    String chartYamlOutputPath = getChartYamlPath(manifestConfig, destinationDirectory);
    Path chartYamlDirectory = Paths.get(chartYamlOutputPath).getParent();
    FileIo.createDirectoryIfDoesNotExist(chartYamlDirectory);
    FileIo.waitForDirectoryToBeAccessibleOutOfProcess(chartYamlDirectory.toString(), 10);
    FileIo.writeFile(
        getChartYamlPath(manifestConfig, destinationDirectory), chartYamlContent.getBytes(StandardCharsets.UTF_8));
  }

  private void fetchHelmChartYamlFromHelmRepo(HelmChartManifestDelegateConfig manifestConfig,
      String destinationDirectory, long timeoutInMillis) throws Exception {
    String chartName = manifestConfig.getChartName();
    String repoName = helmTaskHelperBase.getRepoNameNG(manifestConfig.getStoreDelegateConfig());
    String chartVersion = manifestConfig.getChartVersion();
    if (helmTaskHelperBase.isHelmLocalRepoSet()) {
      String parentDir = helmTaskHelperBase.getHelmLocalRepositoryCompletePath(repoName, chartName, chartVersion);
      helmTaskHelperBase.populateChartToLocalHelmRepo(
          manifestConfig, timeoutInMillis, new NoopExecutionCallback(), parentDir);
      String localChartDirectory = HelmTaskHelperBase.getChartDirectory(parentDir, chartName);
      File chartYamlFile = new File(getChartYamlPath(manifestConfig, localChartDirectory));
      if (!chartYamlFile.exists()) {
        return;
      }

      File destinationFile = new File(getChartYamlPath(manifestConfig, destinationDirectory));
      FileUtils.copyFile(chartYamlFile, destinationFile);
    } else {
      helmTaskHelperBase.downloadHelmChart(
          manifestConfig, timeoutInMillis, new NoopExecutionCallback(), destinationDirectory);
    }
  }

  private File findHelmChartYaml(HelmChartManifestDelegateConfig manifestConfig, String destinationDirectory) {
    String chartYamlSubpath;
    if (isNotEmpty(manifestConfig.getSubChartPath())) {
      chartYamlSubpath = Paths.get(manifestConfig.getSubChartPath(), CHARTS_YAML_KEY).toString();
    } else {
      chartYamlSubpath = CHARTS_YAML_KEY;
    }

    if (isNotEmpty(manifestConfig.getChartName())) {
      File potentialChartYamlFile =
          Paths.get(destinationDirectory, manifestConfig.getChartName(), chartYamlSubpath).toFile();
      if (potentialChartYamlFile.exists()) {
        return potentialChartYamlFile;
      }
    }

    return Paths.get(destinationDirectory, chartYamlSubpath).toFile();
  }

  private String getChartYamlPath(HelmChartManifestDelegateConfig manifestConfig, String basePath) {
    if (isNotEmpty(manifestConfig.getSubChartPath())) {
      return Paths.get(basePath, manifestConfig.getSubChartPath(), CHARTS_YAML_KEY).toString();
    }

    return Paths.get(basePath, CHARTS_YAML_KEY).toString();
  }

  private static HelmChartMetadata createMetadata(HelmChartManifestDelegateConfig config) {
    var metadataBuilder = HelmChartMetadata.builder()
                              .chartName(config.getChartName())
                              .chartVersion(config.getChartVersion())
                              .subChartPath(config.getSubChartPath());

    switch (config.getStoreDelegateConfig().getType()) {
      case HTTP_HELM:
        HttpHelmStoreDelegateConfig httpHelm = (HttpHelmStoreDelegateConfig) config.getStoreDelegateConfig();
        metadataBuilder.url(httpHelm.getHttpHelmConnector().getHelmRepoUrl());
        metadataBuilder.cacheRepoUrl(httpHelm.getHttpHelmConnector().getHelmRepoUrl());
        break;
      case S3_HELM:
        S3HelmStoreDelegateConfig s3Helm = (S3HelmStoreDelegateConfig) config.getStoreDelegateConfig();
        metadataBuilder.region(s3Helm.getRegion())
            .bucketName(s3Helm.getBucketName())
            .basePath(s3Helm.getFolderPath())
            .cacheRepoUrl(format("s3://%s/%s/%s", s3Helm.getRegion(), s3Helm.getBucketName(), s3Helm.getFolderPath()));
        break;
      case GCS_HELM:
        GcsHelmStoreDelegateConfig gcsHelm = (GcsHelmStoreDelegateConfig) config.getStoreDelegateConfig();
        metadataBuilder.bucketName(gcsHelm.getBucketName())
            .basePath(gcsHelm.getFolderPath())
            .cacheRepoUrl(format("gcs://%s/%s", gcsHelm.getBucketName(), gcsHelm.getFolderPath()));
        break;
      case OCI_HELM:
        OciHelmStoreDelegateConfig ociHelm = (OciHelmStoreDelegateConfig) config.getStoreDelegateConfig();
        if (ociHelm.getConnectorConfigDTO() instanceof OciHelmConnectorDTO) {
          metadataBuilder.url(ociHelm.getRepoUrl())
              .basePath(ociHelm.getBasePath())
              .cacheRepoUrl(format("%s/%s", ociHelm.getRepoUrl(), ociHelm.getBasePath()));
        } else if (ociHelm.getConnectorConfigDTO() instanceof AwsConnectorDTO) {
          String repoUrl = getEcrRepoUrl(ociHelm);
          metadataBuilder.url(repoUrl)
              .region(ociHelm.getRegion())
              .registryId(ociHelm.getRegistryId())
              .basePath(ociHelm.getBasePath())
              .cacheRepoUrl(format("%s/%s", repoUrl, ociHelm.getBasePath()));
        }
        break;
      case GIT:
        GitStoreDelegateConfig gitConfig = (GitStoreDelegateConfig) config.getStoreDelegateConfig();
        metadataBuilder.url(gitConfig.getGitConfigDTO().getUrl());
        if (FetchType.COMMIT == gitConfig.getFetchType()) {
          metadataBuilder.commitId(gitConfig.getCommitId());
          metadataBuilder.chartVersion(gitConfig.getCommitId());
          if (isNotEmpty(gitConfig.getPaths())) {
            metadataBuilder.cacheRepoUrl(format("%s/%s/%s", gitConfig.getGitConfigDTO().getUrl(),
                gitConfig.getPaths().get(0), gitConfig.getCommitId()));
          }
        } else {
          metadataBuilder.branch(gitConfig.getBranch());
        }

        if (isNotEmpty(gitConfig.getPaths())) {
          metadataBuilder.basePath(gitConfig.getPaths().get(0));
          metadataBuilder.chartName(gitConfig.getPaths().get(0));
        }
        break;
      default:
        // do nothing
    }

    return metadataBuilder.build();
  }

  private static String getEcrRepoUrl(OciHelmStoreDelegateConfig ociHelmStoreDelegateConfig) {
    AwsInternalConfig awsInternalConfig =
        awsNgConfigMapper.createAwsInternalConfig((AwsConnectorDTO) ociHelmStoreDelegateConfig.getConnectorConfigDTO());
    return awsClient.getEcrImageUrl(awsInternalConfig, ociHelmStoreDelegateConfig.getRegistryId(),
        ociHelmStoreDelegateConfig.getRegion(), ociHelmStoreDelegateConfig.getRepoName());
  }

  @Value
  @Builder
  @EqualsAndHashCode
  private static class HelmChartKey {
    String repoUrl;
    String chartName;
    String chartVersion;
    String subChartPath;
  }

  @Value
  @Builder
  @EqualsAndHashCode
  @FieldNameConstants(innerTypeName = "MetadataKeys")
  private static class HelmChartMetadata {
    String url;
    String chartName;
    String chartVersion;
    String subChartPath;
    String bucketName;
    String basePath;
    String region;
    String commitId;
    String branch;
    String cacheRepoUrl;
    String registryId;

    public Optional<HelmChartKey> toHelmChartKey() {
      if (isEmpty(cacheRepoUrl) || isEmpty(chartVersion)) {
        return Optional.empty();
      }

      return Optional.of(HelmChartKey.builder()
                             .repoUrl(cacheRepoUrl)
                             .chartName(chartName)
                             .chartVersion(chartVersion)
                             .subChartPath(subChartPath)
                             .build());
    }

    public Map<String, String> toMap() {
      Map<String, String> metadataMap = new HashMap<>();
      addNotEmpty(metadataMap, MetadataKeys.url, url);
      addNotEmpty(metadataMap, MetadataKeys.basePath, basePath);
      addNotEmpty(metadataMap, MetadataKeys.bucketName, bucketName);
      addNotEmpty(metadataMap, MetadataKeys.commitId, commitId);
      addNotEmpty(metadataMap, MetadataKeys.branch, branch);
      return metadataMap;
    }

    private static void addNotEmpty(Map<String, String> map, String key, String value) {
      if (isNotEmpty(value)) {
        map.put(key, value);
      }
    }
  }
}
